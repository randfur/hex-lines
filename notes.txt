# 2023-08-25
- Fixed Firefox by using a DataView to write the colour as a u32 directly instead of having it pass through f32 format.
  - Added setHexPoint() and setHexPoints() helper functions to operate on a DataView.
  - Created a point object format to pass in to these or pass in null for empty points.
    - Concerned about performance impact of this object, will probably add a non-object version later.
  - Added hexPointsToArrayBuffer() as convenience helper.
- 2D/3D support
  - There should probably be 2D and 3D versions of this library; hex-lines-2d and hex-lines-3d.
  - For 3D uses like bomber-hex-lines it isn't efficient to do depth sorting and camera transforms on the CPU
  - According to the performance tab in DevTools most of the time is spent on depth sorting.
  - With depth culling depth sorting can be eliminated entirely (at the loss of alpha channel ease of use).

# 2023-08-24
- Added colour support.
  - Using GL blend modes to support alpha.
  - this.gl.blendFunc(this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA) does an interpolation from destination pixel to source pixel using the source's alpha.
  - Exposed rgbaToFloat32() helper function.
    - Weirdly found that object parameter destructuring had better performance than flat parameters??
      - https://jsperf.app/qikobi
      - Need to stress test this perf test but using it for now.
- Reduced vertex count.
  - Only half a hex is required per side now that they're rotated to be aligned with the line.
  - The term hemihex doesn't seem to exist on the internet.
- Changed the enabled logic to discard when either the start or end are size 0.
  - Means dots need two points to be rendered but that's fine.
  - The rendering of hemihexes makes this more okay since two points are needed anyway to make one hex.
- Used bivector logic instead of complex numbers to represent 2D rotation.
  - Was more arithmetic to come to the same result but doesn't use magic ii = -1, instead uses xx = 1 and xy = -yx.
- Added width and height support, input values are now in screen co-ordinates.
- Added pixelSize support, screen co-ordinates are still preserved.
  - Currently pixelSize is applied to the entire canvas, maybe this should be a per draw call decision making use of rendering to an intermediate texture to do the upscaling.
    - Performance cost of this is questionable compared to the current design since line drawing and texture drawing calls will be interleaved.
- Seems to work, what next?
  - Maybe refactor the bomber experiment to use this.
  - Hopefully get much higher performance.
  - See how this is to use.
  - It could probably use just one draw call.

# 2023-08-23
- Wondering about the number of draw calls since repeated shapes can't be instanced since instancing is already being used for the hex line itself.
  - Internet suggests 100s-1000 draw calls are okay.
  - Shouldn't be more than 100s of draw calls in the extreme case here. Should be alright.
- Created GitHub repo: https://github.com/randfur/hex-lines
- Recreated first hex from scratch with a couple of peeks at syntax from original experiment.
- Created hard coded hex line between two points.
- Writing from scratch has yielded a much simpler approach.
  - Down to three parameters per vertex.
  - Basis vectors of start hex, basis vectors of end hex and percentage between start and end.
  - Percentage fits nicely with lerp() (called mix() in GLSL).
- Remaining things:
  - Canvas width, height.
  - Scaling position and size by pixelSize.
  - Adding transform matrix uniform.
- On Firefox white and yellow appear as alpha 0.
  - Turns out those colours when put through the rgbaToFloat32() conversion come out as NaN.
  - Seems like Chrome is passing the exact NaN value through while Firefox is canonicalising it to some other value.
  - Maybe passing all the data via a Float32Array isn't the way to go and instead use a DataView to construct the buffer, this should avoid the issue entirely.

# 2023-08-22
- Library version of [hex-lines-webgl](https://github.com/randfur/experiments/tree/main/2023/hex-lines-webgl).
- Unsure how to manage GPU memory.
- Going to go with very basic approach, everything is a separate buffer and needs to be drawn separately.
- Possible optimisation later if needed would be to bundle multiple things into one buffer.
  - Can probably add that as an additional API.
  - Create a bundle of handles that cannot be mutated.
  - Would be useful for plain playback separate from editing.
- API surface:
  - class HexLinesContext {
      constructor(HTMLCanvasElement);
      add(bufferData): HexLinesHandle;
    }
  - class HexLinesHandle {
      update(bufferData);
      draw();
      remove();
    }
- Every buffer needs to have the vertex attributes bound separately.
  - Using vertex array objects to save on the switching.
