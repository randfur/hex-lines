# 2023-08-26
- 2D/3D
  - Renaming existing code to be 2D.
  - Files are xyz-2d.js, functions are xyz2d().
  - Added utils.js file for sharing stuff.
    - Should probably share a lot of the shader code.
    - 3D shader can probably build on top of the 2D shader.
    - Can turn the 2D stuff into a helper function they both call into with start and end positions.
  - 3D rendering.
    - Will not use actual 3D rendering for now (as in setting w to non-one values).
    - Will do z div in shader just like the bomber experiment does.
    - May change this later, will probably be hard to interop with other 3D rendering that uses traditional perspective matrix transforms.
    - Will see where it becomes a problem and fix then.
    - Need to apply non-perspective camera transforms separate to perspective transforms to draw the line thickness, can't have the HexVertex offsets getting transformed by the camera orientation, they must be in the final xy plane.
- Origin
  - Want to move 0,0 to be in the centre of the canvas instead of top left.
  - Not totally sure it's a good idea to break from convention but my use cases seem like they'll benefit from it.
  - All these quirks of rendering will need good documentation.
    - 0,0 in centre.
    - Bounds are -width/2,-height/2 to width/2,height/2.
    - Perspective controlled by a zDiv parameter.
    - Camera transform must not have perspective in it.
    - All lines need to be terminated by a size 0 hex point including the last one.
    - Drawing a dot requires two hex points in the same location.
- Dots
  - Considering having the dot orientation depend on gl_instanceID.
  - Give it a bit of randomness.
  - Can just cos,sin some function on instance ID.

# 2023-08-25
- Fixed Firefox by using a DataView to write the colour as a u32 directly instead of having it pass through f32 format.
  - Added setHexPoint() and setHexPoints() helper functions to operate on a DataView.
  - Created a point object format to pass in to these or pass in null for empty points.
    - Concerned about performance impact of this object, will probably add a non-object version later.
  - Added hexPointsToArrayBuffer() as convenience helper.
- 2D/3D support
  - There should probably be 2D and 3D versions of this library; hex-lines-2d and hex-lines-3d.
  - For 3D uses like bomber-hex-lines it isn't efficient to do depth sorting and camera transforms on the CPU
  - According to the performance tab in DevTools most of the time is spent on depth sorting.
  - With depth culling depth sorting can be eliminated entirely (at the loss of alpha channel ease of use).

# 2023-08-24
- Added colour support.
  - Using GL blend modes to support alpha.
  - this.gl.blendFunc(this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA) does an interpolation from destination pixel to source pixel using the source's alpha.
  - Exposed rgbaToFloat32() helper function.
    - Weirdly found that object parameter destructuring had better performance than flat parameters??
      - https://jsperf.app/qikobi
      - Need to stress test this perf test but using it for now.
- Reduced vertex count.
  - Only half a hex is required per side now that they're rotated to be aligned with the line.
  - The term hemihex doesn't seem to exist on the internet.
- Changed the enabled logic to discard when either the start or end are size 0.
  - Means dots need two points to be rendered but that's fine.
  - The rendering of hemihexes makes this more okay since two points are needed anyway to make one hex.
- Used bivector logic instead of complex numbers to represent 2D rotation.
  - Was more arithmetic to come to the same result but doesn't use magic ii = -1, instead uses xx = 1 and xy = -yx.
- Added width and height support, input values are now in screen co-ordinates.
- Added pixelSize support, screen co-ordinates are still preserved.
  - Currently pixelSize is applied to the entire canvas, maybe this should be a per draw call decision making use of rendering to an intermediate texture to do the upscaling.
    - Performance cost of this is questionable compared to the current design since line drawing and texture drawing calls will be interleaved.
- Seems to work, what next?
  - Maybe refactor the bomber experiment to use this.
  - Hopefully get much higher performance.
  - See how this is to use.
  - It could probably use just one draw call.

# 2023-08-23
- Wondering about the number of draw calls since repeated shapes can't be instanced since instancing is already being used for the hex line itself.
  - Internet suggests 100s-1000 draw calls are okay.
  - Shouldn't be more than 100s of draw calls in the extreme case here. Should be alright.
- Created GitHub repo: https://github.com/randfur/hex-lines
- Recreated first hex from scratch with a couple of peeks at syntax from original experiment.
- Created hard coded hex line between two points.
- Writing from scratch has yielded a much simpler approach.
  - Down to three parameters per vertex.
  - Basis vectors of start hex, basis vectors of end hex and percentage between start and end.
  - Percentage fits nicely with lerp() (called mix() in GLSL).
- Remaining things:
  - Canvas width, height.
  - Scaling position and size by pixelSize.
  - Adding transform matrix uniform.
- On Firefox white and yellow appear as alpha 0.
  - Turns out those colours when put through the rgbaToFloat32() conversion come out as NaN.
  - Seems like Chrome is passing the exact NaN value through while Firefox is canonicalising it to some other value.
  - Maybe passing all the data via a Float32Array isn't the way to go and instead use a DataView to construct the buffer, this should avoid the issue entirely.

# 2023-08-22
- Library version of [hex-lines-webgl](https://github.com/randfur/experiments/tree/main/2023/hex-lines-webgl).
- Unsure how to manage GPU memory.
- Going to go with very basic approach, everything is a separate buffer and needs to be drawn separately.
- Possible optimisation later if needed would be to bundle multiple things into one buffer.
  - Can probably add that as an additional API.
  - Create a bundle of handles that cannot be mutated.
  - Would be useful for plain playback separate from editing.
- API surface:
  - class HexLinesContext {
      constructor(HTMLCanvasElement);
      add(bufferData): HexLinesHandle;
    }
  - class HexLinesHandle {
      update(bufferData);
      draw();
      remove();
    }
- Every buffer needs to have the vertex attributes bound separately.
  - Using vertex array objects to save on the switching.
